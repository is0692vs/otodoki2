name: "üîÄ Gemini Triage"

on:
  workflow_call:
    inputs:
      additional_context:
        type: "string"
        description: "Any additional context from the request"
        required: false
      language:
        type: "string"
        description: "Response language (default: 'ja' ‚Äî JP)."
        default: "ja"
      gcp_location:
        type: "string"
        description: "GCP location override"
        required: false
        default: ""
      gcp_project_id:
        type: "string"
        description: "GCP project id override"
        required: false
        default: ""
      gcp_service_account:
        type: "string"
        description: "GCP service account override"
        required: false
        default: ""
      gcp_workload_identity_provider:
        type: "string"
        description: "GCP WIF provider override"
        required: false
        default: ""
      gemini_cli_version:
        type: "string"
        description: "Gemini CLI version override"
        required: false
        default: ""
      gemini_debug:
        type: "string"
        description: "Gemini debug override"
        required: false
        default: "false"
      gemini_model:
        type: "string"
        description: "Gemini model override"
        required: false
        default: ""
      use_gemini_code_assist:
        type: "string"
        description: "Whether to use Gemini Code Assist"
        required: false
        default: "false"
      use_vertex_ai:
        type: "string"
        description: "Whether to use Vertex AI"
        required: false
        default: "false"
    secrets:
      GEMINI_API_KEY:
        required: false

concurrency:
  group: "${{ github.workflow }}-triage-${{ github.event_name }}-${{ github.event.pull_request.number || github.event.issue.number }}"
  cancel-in-progress: true

defaults:
  run:
    shell: "bash"

jobs:
  triage:
    runs-on: "ubuntu-slim"
    timeout-minutes: 7
    outputs:
      available_labels: "${{ steps.get_labels.outputs.available_labels }}"
      selected_labels: "${{ steps.collect_selected.outputs.selected_labels }}"
      triaged_issues: "${{ steps.collect_selected.outputs.triaged_issues }}"
    permissions:
      contents: "read"
      issues: "read"
      pull-requests: "read"
    steps:
      - name: "Get repository labels"
        id: "get_labels"
        uses: "actions/github-script@v7"
        with:
          # NOTE: we intentionally do not use the given token. The default
          # GITHUB_TOKEN provided by the action has enough permissions to read
          # the labels.
          script: |-
            const { data: labels } = await github.rest.issues.listLabelsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });

            if (!labels || labels.length === 0) {
              core.setFailed('There are no issue labels in this repository.')
            }

            const labelNames = labels.map(label => label.name).sort();
            core.setOutput('available_labels', labelNames.join(','));
            core.info(`Found ${labelNames.length} labels: ${labelNames.join(', ')}`);
            return labelNames;

      - name: "Check GEMINI_API_KEY presence (debug-only)"
        if: ${{ fromJSON(vars.DEBUG || vars.ACTIONS_STEP_DEBUG || false) }}
        env:
          GEMINI_API_KEY: "${{ secrets.GEMINI_API_KEY }}"
        run: |-
          if [ -z "${GEMINI_API_KEY}" ]; then
            echo "GEMINI_API_KEY_PRESENT=false"
          else
            echo "GEMINI_API_KEY_PRESENT=true"
          fi

      - name: "Run Gemini issue analysis"
        id: "gemini_analysis"
        if: |-
          ${{ steps.get_labels.outputs.available_labels != '' && (inputs.issues_to_triage == '' || inputs.issues_to_triage == null) }}
        uses: "google-github-actions/run-gemini-cli@v0" # ratchet:exclude
        env:
          GITHUB_TOKEN: "" # Do NOT pass any auth tokens here since this runs on untrusted inputs
          GEMINI_API_KEY: "${{ secrets.GEMINI_API_KEY }}"
          ISSUE_TITLE: "${{ github.event.issue.title }}"
          ISSUE_BODY: "${{ github.event.issue.body }}"
          AVAILABLE_LABELS: "${{ steps.get_labels.outputs.available_labels }}"
        with:
          gcp_location: "${{ inputs.gcp_location || vars.GOOGLE_CLOUD_LOCATION || '' }}"
          gcp_project_id: "${{ inputs.gcp_project_id || vars.GOOGLE_CLOUD_PROJECT || '' }}"
          gcp_service_account: "${{ inputs.gcp_service_account || vars.SERVICE_ACCOUNT_EMAIL || '' }}"
          gcp_workload_identity_provider: "${{ inputs.gcp_workload_identity_provider || vars.GCP_WIF_PROVIDER || '' }}"
          gemini_api_key: "${{ secrets.GEMINI_API_KEY }}"
          gemini_cli_version: "${{ inputs.gemini_cli_version || vars.GEMINI_CLI_VERSION || '' }}"
          gemini_debug: "${{ fromJSON(inputs.gemini_debug || vars.DEBUG || vars.ACTIONS_STEP_DEBUG || 'false') }}"
          gemini_model: "${{ inputs.gemini_model || vars.GEMINI_MODEL || '' }}"
          use_gemini_code_assist: "${{ inputs.use_gemini_code_assist || vars.GOOGLE_GENAI_USE_GCA || '' }}"
          use_vertex_ai: "${{ inputs.use_vertex_ai || vars.GOOGLE_GENAI_USE_VERTEXAI || '' }}"
          settings: |-
            {
              "model": {
                "maxSessionTurns": 25
              },
              "telemetry": {
                "enabled": ${{ vars.GOOGLE_CLOUD_PROJECT != '' }},
                "target": "gcp"
              },
              "tools": {
                "core": [
                  "run_shell_command(echo)"
                ]
              },
              "mcpServers": {
                "github": {
                  "command": "docker",
                  "args": [
                      "run",
                      "-i",
                      "--rm",
                      "-e",
                      "GITHUB_PERSONAL_ACCESS_TOKEN",
                      "ghcr.io/github/github-mcp-server:v0.18.0"
                    ],
                  "includeTools": [
                    "issue_read",
                    "list_issues",
                    "search_issues"
                  ],
                  "env": {
                    "GITHUB_PERSONAL_ACCESS_TOKEN": "${GITHUB_TOKEN}"
                  }
                }
              }
            }
          # For reasons beyond my understanding, Gemini CLI cannot set the
          # GitHub Outputs, but it CAN set the GitHub Env.
          prompt: |-
            Âá∫Âäõ„ÅØÂøÖ„ÅöÊó•Êú¨Ë™û„ÅßË°å„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
            ÂøúÁ≠îË®ÄË™û: ${{ inputs.language }}
            ## Role

            You are an issue triage assistant. Analyze the current GitHub issue and identify the most appropriate existing labels. Use the available tools to gather information; do not ask for information to be provided.

            ## Guidelines

            - Only use labels that are from the list of available labels.
            - You can choose multiple labels to apply.
            - When generating shell commands, you **MUST NOT** use command substitution with `$(...)`, `<(...)`, or `>(...)`. This is a security measure to prevent unintended command execution.

            ## Input Data

            **Available Labels** (comma-separated):
            ```
            ${{ env.AVAILABLE_LABELS }}
            ```

            **Issue Title**:
            ```
            ${{ env.ISSUE_TITLE }}
            ```

            **Issue Body**:
            ```
            ${{ env.ISSUE_BODY }}
            ```

            **Output File Path**:
            ```
            ${{ env.GITHUB_ENV }}
            ```

            ## Steps

            1. Review the issue title, issue body, and available labels provided above.

            2. Based on the issue title and issue body, classify the issue and choose all appropriate labels from the list of available labels.

            3. Convert the list of appropriate labels into a comma-separated list (CSV). If there are no appropriate labels, use the empty string.

            4. Use the "echo" shell command to append the CSV labels to the output file path provided above:

                ```
                echo "SELECTED_LABELS=[APPROPRIATE_LABELS_AS_CSV]" >> "[filepath_for_env]"
                ```

                for example:

                ```
                echo "SELECTED_LABELS=bug,enhancement" >> "/tmp/runner/env"
                ```

      - name: "Collect outputs"
        id: "collect_selected"
        uses: "actions/github-script@v7"
        with:
          script: |-
            core.setOutput('selected_labels', process.env.SELECTED_LABELS || '');
            core.setOutput('triaged_issues', process.env.TRIAGED_ISSUES || '');

  label:
    runs-on: "ubuntu-slim"
    needs:
      - "triage"
    if: |-
      ${{ needs.triage.outputs.selected_labels != '' }}
    permissions:
      contents: "read"
      issues: "write"
      pull-requests: "write"
    steps:
      - name: "Apply labels"
        env:
          ISSUE_NUMBER: "${{ github.event.issue.number }}"
          AVAILABLE_LABELS: "${{ needs.triage.outputs.available_labels }}"
          SELECTED_LABELS: "${{ needs.triage.outputs.selected_labels }}"
        uses: "actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea" # ratchet:actions/github-script@v7.0.1
        with:
          # Use the provided token so that the "gemini-cli" is the actor in the
          # log for what changed the labels.
          github-token: "${{ github.token }}"
          script: |-
            // Parse the available labels
            const availableLabels = (process.env.AVAILABLE_LABELS || '').split(',')
              .map((label) => label.trim())
              .sort()

            // Parse the label as a CSV, reject invalid ones - we do this just
            // in case someone was able to prompt inject malicious labels.
            const selectedLabels = (process.env.SELECTED_LABELS || '').split(',')
              .map((label) => label.trim())
              .filter((label) => availableLabels.includes(label))
              .sort()

            // Set the labels
            const issueNumber = process.env.ISSUE_NUMBER;
            if (selectedLabels && selectedLabels.length > 0) {
              await github.rest.issues.setLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                labels: selectedLabels,
              });
              core.info(`Successfully set labels: ${selectedLabels.join(',')}`);
            } else {
              core.info(`Failed to determine labels to set. There may not be enough information in the issue or pull request.`)
            }
